### Custom procedures ###
## This is the place for all the procedures needed for the other scripting.
# Descriptions for all the procedures are above the procedures.

### CHECK_ERROR: check_error <error message> <first if> <second if>
##  Does a simple statement of 'if "first if" == "second if"' and returns an error if it does
proc check_error {text var tok} {
  if {$var == $tok} {
    error "wrong # args: should \"$text\""
    return return
  }
}

### NOTICE: notice <nick> <handle> <text>
##  Used to /notice nicknames
proc notice {{nick &NA&} {handle &NA&} {text &NA&}} {
  check_error "notice nickname handle text" $text &NA&
  if {![validuser $handle] || ![nickinfo $handle interface]} {
    puthelp "NOTICE $nick :$text"
  } else {
    puthelp "PRIVMSG $nick :$text"
  }
}

### MSG: msg <nickname> <text>
##  Used to /msg nicknames/channels
proc msg {{nick &NA&} {text &NA&}} {
  check_error "msg nickname text" $text &NA&
  puthelp "PRIVMSG $nick :$text"
}

### -USER: -user <nick-deleted> <channel>
##  Deletes a user from a specific channel
proc -user {{nick &NA&} {chan &NA&}} {
  check_error "-user nickname chan" $chan &NA&
  global set
  setuser $nick XTRA LEVEL([string toupper $chan])
  setuser $nick XTRA AOP([string toupper $chan])
  setuser $nick XTRA AOV([string toupper $chan])
  setuser $nick XTRA PROTECT([string toupper $chan])
  setuser $nick XTRA LASTMOD([string toupper $chan])
  setuser $nick XTRA LASTSEEN([string toupper $chan])
  if {![file isfile $set(data.dir)/$set(deluser.file)]} {
    return
  }
  set rfile [open $set(data.dir)/$set(deluser.file) "RDONLY"]
  eval [read $rfile]
  close $rfile
}

### +USER: +user <nick-added> <channel> <added-by-who> <by-who-userhost> <level> <aop> <aov> <protect> <userhost>
##  Add a user to a specific channel
proc +user {{nick &NA&} {chan &NA&} {handle &NA&} {uhost &NA&} {lvl &NA&} {aop &NA&} {aov &NA&} {pro &NA&} {uh &NA&}} {
  global set
  check_error "+user new-nickname channel add-handle add-userhost level aop aov protect userhost" $uh &NA&
  setuser $nick XTRA LEVEL([string toupper $chan]) $lvl
  setuser $nick XTRA AOP([string toupper $chan]) $aop
  setuser $nick XTRA AOV([string toupper $chan]) $aov
  setuser $nick XTRA PROTECT([string toupper $chan]) $pro
  setuser $nick XTRA LASTMOD([string toupper $chan]) "[unixtime] $handle $uhost"
  setuser $nick XTRA LASTSEEN([string toupper $chan]) [unixtime]
  setuser $nick HOSTS $uh
  if {![file isfile $set(data.dir)/$set(adduser.file)]} {
    return
  }
  set rfile [open $set(data.dir)/$set(adduser.file) "RDONLY"]
  eval [read $rfile]
  close $rfile
}

### +SUSPEND: +suspend <channel> <handle> <time in seconds> <reason>
##  Sets a user suspended, sending the notice
proc +suspend {{chan &NA&} {handle &NA&} {time &NA&} {reason &NA&}} {
  check_error "+suspend channel handle time reason" $reason &NA&
  global set
  if {![validuser $handle]} {
    return
  } elseif {![suspend $handle $chan]} {
    setuser $handle xtra SUSPEND([string toupper $chan]) 1
    setuser $handle xtra SUSPENDR([string toupper $chan]) $reason
    checkusers
    setuser &suspend& xtra $chan,$handle "[expr [unixtime] + $time] [timer [expr $time / 60] "-suspend $chan $handle"]"
    if {[notify $handle]} {
      notice $handle $handle "You have been suspended on $chan for [expr $time / 60] minutes"
    }
  } else {
    if {[istimer [string trimleft [lindex [suspendinfo $chan $handle] 1] timer]]} {
      killtimer [lindex [suspendinfo $chan $handle] 1]
    }
    setuser $handle xtra SUSPENDR([string toupper $chan]) $reason
    checkusers
    setuser &suspend& xtra $chan,$handle "[expr [lindex [suspendinfo $chan $handle] 0] + $time] [timer [expr ($time / 60) + ([lindex [suspendinfo $chan $handle] 0] - [unixtime]) / 60] "-suspend $chan $handle"]"
    if {[notify $handle]} {
      notice $handle $handle "You have been suspended on $chan for an extra [expr $time / 60] minutes"
    }
  }
}

### -SUSPEND: -suspend <channel> <handle>
##  Unsuspends a user in a channel
proc -suspend {{chan &NA&} {handle &NA&}} {
  check_error "-suspend channel handle" $handle &NA&
  global set
  if {![validuser $handle]} {
    putlog "> Could not unsuspend $handle on $chan.. nickname does not exist."
  } elseif {[level $handle $chan] == "0"} {
    putlog "> Could not unsuspend $handle on $chan.. they do not have access."
  } else {
    putlog "> Suspension on $chan for $handle expired."
    setuser $handle xtra SUSPEND([string toupper $chan]) 0
    setuser $handle xtra SUSPENDR([string toupper $chan])
    foreach timer [timers] {
      if {[string tolower [lindex $timer 1]] == [string tolower "-suspend $chan $handle"]} {
        killtimer [lindex $timer 2]
      }
    }
    checkusers
    setuser &suspend& xtra $chan,$handle
  }
}

### SUSPENDINFO: suspendinfo <channel> <handle>
##  Returns the 'ctime timernumber' of the suspension
proc suspendinfo {{chan &NA&} {handle &NA&}} {
  check_error "suspendinfo channel handle" $handle &NA&
  checkusers
  return [getuser &suspend& xtra $chan,$handle]
}

### CHANGE: change <word> <type>
##  To change '0/1' into 'Yes/No' or 'On/Off' and vise-versa
proc change {{word &NA&} {type &NA&}} {
  check_error "change word type" $type &NA&
  set type [string tolower $type]
  set word [string tolower $word]
  if {($word == "yes" || $word == "on" || $word == "1") && $type == "10"} {
    return 1
  } elseif {($word == "yes" || $word == "on" || $word == "1") && $type == "onoff"} {
    return On
  } elseif {($word == "yes" || $word == "on" || $word == "1") && $type == "yesno"} {
    return Yes
  } elseif {($word == "no" || $word == "off" || $word == "0") && $type == "10"} {
    return 0
  } elseif {($word == "no" || $word == "off" || $word == "0") && $type == "onoff"} {
    return Off
  } elseif {($word == "no" || $word == "off" || $word == "0") && $type == "yesno"} {
    return No
  } else {
    return
  }
}

### FINDIDX: findidx <idx>
##  Find's the information of a specific idx of a dcc
proc findidx {{idx &NA&}} {
  check_error "findidx idx" $idx &NA&
  foreach num [dcclist] {
    if {[lindex $num 0] == $idx} {
      return $num
    }
  }
}

### LEVEL: level <handle> <channel>
##  See the level of a handle in a channel
proc level {{handle &NA&} {chan &NA&}} {
  check_error "level handle channel" $chan &NA&
  check_error " handle channel" $chan &NA&
  if {![validuser $handle] || [getuser $handle xtra level($chan)] == ""} {
    return 0
  } else {
    return [getuser $handle xtra level($chan)]
  }
}

### AOP: aop <handle> <channel>
##  See the AOP status of a handle in a channel
proc aop {{handle &NA&} {chan &NA&}} {
  check_error "aop handle channel" $chan &NA&
  if {![validuser $handle] || [getuser $handle xtra aop($chan)] == ""} {
    return 0
  } else {
    return [getuser $handle xtra aop($chan)]
  }
}

### AOV: aov <handle> <channel>
##  See the AOV status of a handle in a channel
proc aov {{handle &NA&} {chan &NA&}} {
  check_error "aov handle channel" $chan &NA&
  if {![validuser $handle] || [getuser $handle xtra aov($chan)] == ""} {
    return 0
  } else {
    return [getuser $handle xtra aov($chan)]
  }
}

### PROTECT: protect <handle> <channel>
##  See the Protection status of a handle in a channel
proc protect {{handle &NA&} {chan &NA&}} {
  check_error "protect handle channel" $chan &NA&
  if {![validuser $handle] || [getuser $handle xtra protect($chan)] == ""} {
    return 0
  } else {
    return [getuser $handle xtra protect($chan)]
  }
}

### SUSPEND: suspend <handle> <channel>
##  See the Suspension status of a handle in a channel
proc suspend {{handle &NA&} {chan &NA&}} {
  check_error "suspend handle channel" $chan &NA&
  if {![validuser $handle] || [getuser $handle xtra suspend($chan)] == ""} {
    return 0
  } else {
    return [getuser $handle xtra suspend($chan)]
  }
}

### REPLACE: replace <text> <character> <replacing-with>
##  Replaces 'character' with 'replacing-with' (single characters only)
proc replace {{text &NA&} {tok &NA&} {rep &NA&}} {
  check_error "replace text token replacement-token" $rep &NA&
  set atext ""
  foreach char [split $text ""] {
    if {$char == $tok} {
      set atext $atext$rep
    } else {
      set atext $atext$char
    }
  }
  return $atext
}

### EXTEXT: extext <text> <word>
##  Removed 'word' from 'text'
proc extext {{text &NA&} {word &NA&}} {
  check_error "extext text word" $word &NA&
  set words ""
  foreach w $text {
    if {[string tolower $word] != [string tolower $w]} {
      set words "$words $w"
    }
  }
  return [string trimleft $words " "]
}

### COMCHAN: comchan <nickname>
##  Returns the common channels of nickname and botnick
proc comchan {{nick &NA&}} {
  check_error "comchan nickname" $nick &NA&
  set chans ""
  foreach chan [channels] {
    if {[onchan $nick $chan]} {
      set chans "$chans $chan"
    }
  }
  return [string trimleft $chans " "]
}

### ISSPECIAL: isspecial <handle> <channel>
##  Tells if a handle is a special user (+n, +m etc.)
proc isspecial {{handle &NA&} {chan ""}} {
  check_error "isspecial handle ?channel?" $handle &NA&
  if {[matchattr $handle +n]} {
    return 300
  } elseif {[matchattr $handle |+n $chan]} {
    return 300
  } elseif {[matchattr $handle |+m $chan]} {
    return 200
  } elseif {[matchattr $handle +m]} {
    return 200
  } elseif {[matchattr $handle |+o $chan]} {
    return 100
  } elseif {[matchattr $handle +o]} {
    return 100
  } else {
    return 0
  }
}

### GETCHANNELACCESS: getchannelaccess <handle>
##  Returns the channels a nickname has access in
proc getchannelaccess {{handle &NA&}} {
  check_error "getchannelaccess handle" $handle &NA&
  if {![validuser $handle]} {
    return
  }
  set channels ""
  foreach info [getuser $handle xtra] {
    if {[string tolower [letters $info 5]] == "level"} {
      set chan [string trimright [string trimleft [lindex $info 0] LEVEL(] )]
      set channels "$channels \{$chan [level $handle $chan] [aop $handle $chan] [aov $handle $chan] [protect $handle $chan]\}"
    }
  }
  return [string trimleft $channels " "]
}

### ISHOST: ishost <handle> <hostname>
##  Checks if the 'handle' has the 'hostname' added to their host list
proc ishost {{handle &NA&} {host &NA&}} {
  check_error "ishost hostname" $host &NA&
  foreach userhost [getuser $handle hosts] {
    if {$userhost == $host} {
      return "1"
    }
  }
  return "0"
}

### GETSTRING: getstring <string>
##  Changes 'nickname' into '*!*ident@*.isp.com' for example. Used for +ban/-ban commands
proc getstring {{string &NA&}} {
  check_error "getstring banmask" $string &NA&
  if {[string match !*@ $string] == "1"} {
    return *$string*
  } elseif {[string match !* $string] == "1"} {
    return *$string@*
  } elseif {[string match @* $string] == "1"} {
    return *!*$string
  } elseif {[string match !*@* $string] == "1"} {
    return *$string
  } elseif {[string match *!*@ $string] == "1"} {
    return $string*
  } elseif {[string match *! $string] == "1"} {
    return $string*@*
  } elseif {[string match *@ $string] == "1"} {
    return *!$string*
  } elseif {[string match *@* $string] == "1" && [string match *!* $string] == "0"} {
    return *!$string
  } elseif {[string match *!*@* $string] == "1"} {
    return $string
  } elseif {[getchanhost $string] != ""} {
    return [maskhost [getchanhost $string]]
  } else {
    return $string!*@*
  }
}

### LASTMOD: lastmod <handle> <chan>
##  See who last modified a handle in a channel and when
proc lastmod {{handle &NA&} {chan &NA&}} {
  check_error "lastmod handle channel" $chan &NA&
  if {![validuser $handle] || [getuser $handle xtra lastmod($chan)] == ""} {
    return 0
  } else {
    return [getuser $handle xtra lastmod($chan)]
  }
}

### LASTSEEN: lastseen <handle> <chan>
##  See when a handle was last seen on a channel
proc lastseen {{handle &NA&} {chan &NA&}} {
  check_error "lastseen handle channel" $chan &NA&
  if {![validuser $handle] || [getuser $handle xtra lastseen($chan)] == ""} {
    return 0
  } else {
    return [getuser $handle xtra lastseen($chan)]
  }
}

### ACCESS: access <channel> <min level>
##  Filters out all the nicknames who have a level equal or higher to 'min level' on a channel
proc access {{chan &NA&} {level 1}} {
  check_error "access channel ?level?" $chan &NA&
  global set
  set users ""
  foreach user [userlist] {
    if {[level $user $chan] >= $level} {
      set users "$users $user"
    }
  }
  return [string trimleft $users " "]
}

### ISMODE: ismode <mode> <type>
##  Checks to see if a mode is a 'type' mode (channel, user, two)
proc ismode {{mode &NA&} {type &NA&}} {
  check_error "ismode mode type" $type &NA&
  global set
  foreach m [split $set([string tolower $type]mode) ""] {
    if {$mode == $m} {
      return 1
    }
  }
  return 0
}

### CHARSTRIP: charstrip <text>
##  Similar to '$strip' in mIRC but removes ALL codes for bold/colour/reverse/underline
proc charstrip {{text &NA&}} {
  check_error "charstrip text" $text &NA&
  regsub -all {[0-9]{0,2}(,[0-9]{0,2})?} $text "" text
  regsub -all \[\] $text "" text
  return $text
}

### ISNUM: isnum <text>
##  Checks to see if the text is a number or not
proc isnum {{text &NA&}} {
  check_error "isnum text" $text &NA&
  foreach char [split $text ""] {
    if {![string match \[0-9\] $char] && $char != "."} { return 0 }
  }
  return 1
}

### CONNECT_SETTINGS: connect_settings
##  Checks settings that can't be checked when the eggdrop gets started
proc connect_settings {} {
  global set botnick
  if {![istimer connect_settings]} {
    timer 120 connect_settings
  }
  putlog "> Checking user status... Levels, users..."
  putlog "> Checking banlist and suspension list..."
  checkusers
  foreach ban [getuser &banlist& xtra] {
    set b_chan [lindex [replace [lindex $ban 0] , " "] 0]
    set b_mask [lindex [replace [lindex $ban 0] , " "] 1]
    if {$b_chan == "" || $b_mask == ""} {
      continue
    } elseif {![isban $b_mask $b_chan]} {
      setuser &banlist& xtra [lindex $ban 0]
    }
  }
  foreach suspend [getuser &suspend& xtra] {
    set s_chan [lindex [replace [lindex $suspend 0] , " "] 0]
    set s_nick [lindex [replace [lindex $suspend 0] , " "] 1]
    if {$s_chan == "" || $s_nick == ""} {
      continue
    } elseif {![suspend $s_nick $s_chan] || [lindex [suspendinfo $s_chan $s_nick] 0] <= [unixtime]} {
      -suspend $s_chan $s_nick
    } elseif {![istimer [string trimleft [lindex [suspendinfo $s_chan $s_nick] 1] timer]]} {
      setuser &suspend& xtra $s_chan,$s_nick "[lindex [suspendinfo $s_chan $s_nick] 0] [timer [expr ([lindex [suspendinfo $s_chan $s_nick] 0] - [unixtime]) / 60] "-suspend $s_chan $s_nick"]"
    }
  }
}

### SERVER_CONNECT: server_connect
##  Does all the shit instead of putting it in '$init-server' variable
proc server_connect {} {
  global botnick set notify
  putquick "MODE $botnick $set(servermode)"
  foreach user [userlist] {
    if {$user != "&banlist&" && $user != "&suspend&"} {
      setuser $user XTRA AUTH 0
    }
  }
  if {![info exists notify]} {
    set notify([string tolower $botnick]) 1
  }
  putserv "ISON :$botnick [userlist]"
  putquick "PRIVMSG #Testikles` :Loaded Services v[lindex $set(version) 0] ([ctime [unixtime]] $set(timezone))"
  connect_settings
}

### AUTH_AUTOMODE: auth_automode <nickname> <handle> <userhost>
##  Used after authentication to auto-OP/Voice a handle in channels they are on 
proc auth_automode {{nick &NA&} {handle &NA&} {uhost &NA&}} {
  check_error "auth_automode nickname handle userhost" $uhost &NA&
  global set
  set chans ""
  foreach chan $set(channels) {
    if {[level $handle $chan] > "0"} {
      if {![changet $chan active]} {
        set chans "$chans, $chan \[Not Active\]"
      } elseif {![botisop $chan]} {
        set chans "$chans, $chan \[Bot Not Opped\]"
      } elseif {![onchan $nick $chan]} {
        set chans "$chans, $chan \[Not On\]"
      } elseif {[suspend $handle $chan]} {
        set chans "$chans, $chan \[Suspended\]"
      } elseif {[aop $handle $chan] && [level $handle $chan] < [changet $chan oprestrict]} {
        set chans "$chans, $chan \[AOP (oprestict)\]"
      } elseif {[aop $handle $chan]} {
        set chans "$chans, $chan \[AOP\]"
        if {![isop $nick $chan]} {
          pushmode $chan +o $nick
        }
      } elseif {[aov $handle $chan]} {
        set chans "$chans, $chan \[AOV\]"
        if {![isvoice $nick $chan]} {
          pushmode $chan +v $nick
        }
      }
    }
  }
  homechan "\[$handle\]($nick!$uhost): authentication status: [string trimleft $chans ", "]"
  if {![file isfile $set(data.dir)/$set(auth.file)]} {
    return
  }
  set rfile [open $set(data.dir)/$set(auth.file) "RDONLY"]
  eval [read $rfile]
  close $rfile
}

### DEAUTH_AUTOMODE: deauth_automode <nickname> <handle>
##  Used after deauthentication to auto-DeOP/Voice a handle in channels they are on
proc deauth_automode {{nick &NA&} {handle &NA&}} {
  check_error "deauth_automode nickname handle" $handle &NA&
  global set
  foreach chan $set(channels) {
    if {[level $handle $chan] > "0" && [changet $chan active]} {
      if {[isop $nick $chan]} {
        pushmode $chan -o $nick
      }
      if {[isvoice $nick $chan]} {
        pushmode $chan -v $nick
      }
    }
  }
  if {![file isfile $set(data.dir)/$set(deauth.file)]} {
    return
  }
  set rfile [open $set(data.dir)/$set(deauth.file) "RDONLY"]
  eval [read $rfile]
  close $rfile
}

### AUTH_CHECK: auth_check <nickname> <userhost> <handle> <channel>
##  Checks all settings against handle's to make sure they are authenticated properly
proc auth_check {{nick &NA&} {uhost &NA&} {handle &NA&} {chan &NA&}} {
  check_error "auth_check nickname userhost handle channel" $chan &NA&
  global set
  if {![validuser $handle]} {
    return 0
  } elseif {![nickinfo $handle auth]} {
    notice $nick $handle "You are not yet authenticated."
    return 0
  } elseif {[nickinfo $handle userhost] != $uhost} {
    notice $nick $handle "Your current userhost of '$uhost' is not the one you authenticated with."
    return 0
  } elseif {![ischanopchan $chan] && [level $handle $chan] > "0"} {
    notice $nick $handle "$chan is not currently being supervised by Services"
    return 0
  } elseif {![changet $chan active]} {
    notice $nick $handle "Invalid request: $chan isn't currently activated"
    return 0
  } elseif {[suspend $handle $chan]} {
    notice $nick $handle "You are currently suspended in $chan. Your commands are being ignored."
    return 0
  } else {
    return 1
  }
}

### BACKUP_CHECK: backup_check <channel>
##  Checks the 'channel' for one of the backup bots, returns if it should continue to process commands
proc backup_check {{chan ""}} {
  check_error "backup_check ?channel?" "" &NA&
  global set
  set return 0
  if {$chan == ""} {
    foreach botnick $set(backup) {
      if {[getchanhost $botnick] != "" && [string tolower [nick2hand $botnick]] == [string tolower $botnick]} {
        set return 1
      }
    }
    return $return
  }
  if {![validchan $chan] || ![botisop $chan]} {
    return 0
  }
  foreach botnick $set(backup) {
    if {[isop $botnick $chan] && [string tolower [nick2hand $botnick]] == [string tolower $botnick]} {
      set return 1
    } elseif {[onchan $botnick $chan] && ![isop $botnick $chan] && [validuser $botnick] && [matchattr $botnick o] && [matchattr $botnick a] && [string tolower [nick2hand $botnick]] == [string tolower $botnick]} {
      set return 1
      pushmode $chan +o $botnick
      putcmdlog "> Opped preceeding backup bot $botnick on $chan after checking for authenticity."
    }
  }
  return $return
}

### LETTERS: letters <text> <number> [<type[1/0]>]
##  Similar to $left/$right in mIRC 1 = right, 0 = left
proc letters {{text &NA&} {num &NA&} {type 1}} {
  check_error "letters text number ?type?" $num &NA&
  set c 0
  set r ""
  if {!$type} {
    set e 0
    foreach let [split $text ""] {
      if {$c == $num} {
        set e 1
        set r $r$let
        incr c 1
      } elseif {!$e} {
        incr c 1
      } else {
        set r $r$let
        incr c 1
      }
    }
    return $r
  } elseif {$type} {
    foreach let [split $text ""] {
      if {$c == $num} {
        return $r
      }
      set r $r$let
      incr c 1
    }
    return $r
  }
}

### ISTIMER: istimer <number/command>
##  Returns 1/0 for if there is timer matching the number/command
proc istimer {{n &NA&}} {
  check_error "istimer number|command" $n &NA&
  foreach timer [timers] {
    if {[isnum $n] && [lindex $timer 2] == "timer$n"} {
      return 1
    } elseif {![isnum $n] && [string tolower [lindex $timer 1]] == [string tolower $n]} {
      return 1
    }
  }
  return 0
}

### ISUTIMER: isutimer <number/command>
##  Returns 1/0 for if there is utimer matching the number/command
proc isutimer {{n &NA&}} {
  check_error "isutimer number|command" $n &NA&
  foreach timer [utimers] {
    if {[isnum $n] && [lindex $timer 2] == "timer$n"} {
      return 1
    } elseif {[string tolower [lindex $timer 1]] == [string tolower $n]} {
      return 1
    }
  }
  return 0
}

### SEARCH_BOTOP: search_botop <channel>
##  Searches all connected bots for one that's op'd in a channel and asks for an op
proc search_botop {{chan &NA&}} {
  check_error "search_botop channel" $chan &NA&
  global set
  foreach bot [bots] {
    if {[isop [hand2nick $bot] $chan]} {
      putbot $bot "opme $chan"
    }
  }
}

### NICKINFO: nickinfo <nickname> <setting>
##  Basically gets information from [getuser handle XTRA setting]
proc nickinfo {{handle &NA&} {setting &NA&}} {
  check_error "nickinfo handle setting" $setting &NA&
  if {![validuser $handle] || [getuser $handle xtra $setting] == ""} {
    return 0
  } else {
    return [getuser $handle xtra $setting]
  }
}

### COMGET: comget <channel> <command>
##  Returns the access level needed to use the 'command' on the 'channel'
proc comget {{chan &NA&} {command &NA&}} {
  check_error "comget channel command" $command &NA&
  global set cominfo
  set tmp [readfile $set(data.dir)/[file_change $chan].com $command]
  if {$tmp == ""} {
    return 0
  } else {
    return $tmp
  }
}

### CHANGET: changet <channel> <setting>
##  Returns various information about the 'channel'
proc changet {{chan &NA&} {setting &NA&}} {
  check_error "changet channel setting" $setting &NA&
  global set chaninfo
  set tmp [readfile $set(data.dir)/[file_change $chan].dat $setting]
  if {$tmp == ""} {
    return 0
  } else {
    return $tmp
  }
}

### CHANSET
proc chanset {{chan &NA&} {info &NA&} {value &NA}} {
  check_error "chanset channel setting value" $value &NA&
  global set
  writefile $set(data.dir)/[file_change $chan].dat $info $value
}

### ISCHANOPCHAN: ischanopchan <channel>
##  Checks to see if a channel is monitored by the script
proc ischanopchan {{chan &NA&}} {
  global set
  check_error "ischanopchan channel" $chan &NA&
  foreach channel $set(channels) {
    if {[string tolower $channel] == [string tolower $chan]} {
      return 1
    }
  }
  return 0
}

### HOMECHAN: homechan <text>
##  Sends a message to the home channel (this is via botnet if the option is available)
proc homechan {{text &NA&}} {
  check_error "homechan text" $text &NA&
  global set
  if {$set(report)} {
    msg $set(homechan) $text
  } 
}

### CHECK_SETTINGS: check_settings
##  Check's all settings, making new settings if needed, changing old if needed and running commands
proc check_settings {} {
  global set botnick
  if {![istimer check_settings]} {
    timer 120 check_settings
  }
  putlog "> Authenticating to Nickname service..."
  if {$set(nickpass) != ""} {
    if {$set(nickusemsg)} {
      msg $set(nickserv) "identify $set(nickpass)"
    } else {
      putquick "$set(nickserv) "identify $set(nickpass)"
    }
  }
  putlog "> Checking socket settings..."
  if {$set(sockcommand)} {
    listen $set(listenport) script listen_command
  } elseif {!$set(sockcommand)} {
    catch {listen $set(listenport) off}
  }
  set cnt 0
  set cnt2 0
  foreach user [userlist] {
    if {[getchannelaccess $user] == "" && [isspecial $user] == "0" && ![matchattr $user U] && ![matchattr $user b]} {
      deluser $user
      putlog "> Found $user to have no access anywhere.. removing..."
      file delete $set(data.dir)/note.[file_change $user]
      incr cnt 1
      continue
    }
    foreach chaninfo [getchannelaccess $user] {
      set channel [lindex $chaninfo 0]
      if {[level $user $channel] <= "0" || [level $user $channel] > "200"} {
        setuser $user XTRA LEVEL($channel) [lindex $set(autoadd) 0]
        setuser $user XTRA AOP($channel) [lindex $set(autoadd) 1]
        setuser $user XTRA AOV($channel) [lindex $set(autoadd) 2]
        setuser $user XTRA PROTECT($channel) [lindex $set(autoadd) 3]
        setuser $user XTRA LASTMOD($channel) $botnick!bogus-settings@testikles.org
        setuser $user XTRA LASTSEEN($channel) [unixtime]
        putlog "> Found $user to have a bogus level of [level $user $channel] on $channel... resetting to [lindex $set(autoadd) 0]"
        incr cnt2 1
      }
    }
  }
  if {$cnt > "0"} {
    homechan "Removed $cnt users from the database.. they have no access anywhere."
  }
  if {$cnt2 > "0"} {
    homechan "Reset $cnt bogus level's to level [lindex $set(autoadd) 0]"
  }
  putlog "> Checking channel settings..."
  foreach channel $set(channels) {
    if {![file isfile $set(data.dir)/[file_change $channel].dat]} {
      addmainchan $channel
    }
    if {![file isfile $set(data.dir)/[file_change $channel].com]} {
      command_create $channel
    }
    if {![changet $channel active]} {
      continue
    } elseif {![validchan $channel]} {
      channel add $channel
      putlog "> Added main channel $channel..."
      channel set $channel chanmode ""
    }
  }
  if {![validchan $set(homechan)]} {
    channel add $set(homechan)
    putlog "> Added home channel..."
  }
  putlog "> Checking operator status on main channels..."
  foreach channel $set(channels) {
    if {[changet $channel active] && [validchan $channel] && ![botisop $channel] && [onchan $botnick $channel]} {
      homechan "I'm not an operator on $channel."
      putlog "> I'm not an operator on $channel, checking if another bot can op me"
      search_botop $channel
    }
  }
  putlog "> Checked all general settings..."
}

### NICKSETTINGS: nicksettings <handle>
##  Returns the nickname options for a handle
proc nicksettings {{handle &NA&}} {
  check_error "nicksettings handle" $handle &NA&
  set settings ""
  if {[nickinfo $handle telladd]} {
    set settings "$settings, Note on adduser"
  }
  if {[nickinfo $handle tellset]} {
    set settings "$settings, Note on setuser"
  }
  if {[nickinfo $handle telldel]} {
    set settings "$settings, Note on deluser"
  }
  if {[nickinfo $handle interface] == "0"} {
    set settings "$settings, NOTICE Interface"
  } else {
    set settings "$settings, PRIVMSG Interface"
  }
  return [string trimleft $settings ", "]
}

### NEWUSER: newuser <handle> <userhost>
##  Adds a new user to the bot, not a specific channel
proc newuser {{handle &NA&} {userhost &NA&} {uhost &NA&}} {
  check_error "newuser handle host userhost" $uhost &NA&
  adduser $handle $userhost
  setuser $handle XTRA USERHOST [getchanhost $handle]
  setuser $handle XTRA AUTH 0
  setuser $handle XTRA SERVICES 1
  setuser $handle XTRA FIRSTHOST $uhost
}

### OWNERSETTINGS: ownersettings <channel>
##  Returns the owner settings of a channel
proc ownersettings {{chan &NA&}} {
  check_error "ownersettings channel" $chan &NA&
  global botnick set
  set ownersettings ""
  if {[changet $chan oprestrict] > "0"} {
    set ownersettings "$ownersettings, OpRestricted to [changet $chan oprestrict]"
  }
  if {[changet $chan mustid]} {
    set ownersettings "$ownersettings, MustID"
  }
  if {[onchan $botnick $chan]} {
    set ownersettings "$ownersettings, On Channel"
  }
  if {[changet $chan telladd]} {
    set ownersettings "$ownersettings, Notify adduser"
  }
  if {[changet $chan tellsetu]} {
    set ownersettings "$ownersettings, Notify setuser"
  }
  if {[changet $chan telldel]} {
    set ownersettings "$ownersettings, Notify deluser"
  }
  if {[changet $chan tellset]} {
    set ownersettings "$ownersettings, Notify set"
  }
  if {[changet $chan tellpeak]} {
    set ownersettings "$ownersettings, Notify peak break"
  }
  if {[changet $chan funmsg]} {
    set ownersettings "$ownersettings, Fun Messages"
  }
  if {[changet $chan reportlog]} {
    set ownersettings "$ownersettings, Report Log"
  }
  return [string trimleft $ownersettings ", "]
}

### DELMAINCHAN: delmainchan <channel>
##  Removes a channel from the script settings completely, this will not remove it from the eggdrop database
proc delmainchan {{chan &NA&}} {
  check_error "delmainchan channel" $chan &NA&
  global set
  if {[file isfile $set(data.dir)/[file_change $chan].dat]} {
    file delete $set(data.dir)/[file_change $chan].dat
  }
  if {[file isfile $set(data.dir)/[file_change $chan].com]} {
    file delete $set(data.dir)/[file_change $chan].com
  }
  if {[file isfile $set(data.dir)/[file_change $chan].logfile]} {
    file delete $set(data.dir)/[file_change $chan].logfile
  }
  setinfo channels [extext $set(channels) $chan]
  checkusers
  foreach suspend [getuser &suspend& xtra] {
    if {[lindex [split [lindex $suspend 0] ","] 0] == $chan} {
      checkusers
      setuser &suspend& xtra [lindex $suspend 0]
    }
  }
  foreach ban [getuser &banlist& xtra] {
    if {[lindex [split [lindex $ban 0] ","] 0] == $chan} {
      checkusers
      setuser &banlist& xtra [linex $ban 0]
    }
  }
}
  
### ADDMAINCHAN: addmainchan <channel>
##  Just add's the main channel settings into the file so all commands work properly
proc addmainchan {{chan &NA&}} {
  check_error "addmainchan channel" $chan &NA&
  global set
  if {![validchan $chan]} {
    channel add $chan
    channel set $chan chanmode ""
  } elseif {[lindex [channel info $chan] 0] != ""} {
    channel set $chan chanmode ""
  }
  if {[file isfile $set(data.dir)/[file_change $chan].dat]} {
    file delete $set(data.dir)/[file_change $chan].dat
  }
  set wfile [open $set(data.dir)/[file_change $chan].dat "WRONLY CREAT"]
  puts $wfile "channel==$chan"
  puts $wfile "active==1"
  puts $wfile "peak==[llength [chanlist $chan]] [unixtime]"
  puts $wfile "owner==$set(owner)"
  puts $wfile "url==No URL set"
  puts $wfile "modelock==100 +nt"
  puts $wfile "keeptopic==100"
  puts $wfile "topic==[topic $chan]"
  puts $wfile "created==[unixtime]"
  puts $wfile "oprestrict==0"
  puts $wfile "mustid==1"
  puts $wfile "telladd==0"
  puts $wfile "tellset==0"
  puts $wfile "telldel==0"
  puts $wfile "tellsetu==0"
  puts $wfile "tellpeak==0"
  puts $wfile "funmsg==1"
  puts $wfile "reportlog==0"
  puts $wfile "restrict==0"
  puts $wfile "nonote==25"
  puts $wfile "quota==300"
  puts $wfile "banquote==300"
  puts $wfile "accessall==190 5"
  puts $wfile "hash==[rand 999]"
  puts $wfile "idle==[unixtime]"
  puts $wfile "manseen==[unixtime]"
  close $wfile
  command_create $chan
  setinfo channels "$set(channels) $chan"
}

### GETINFO: getinfo
##  Reads all of the information from the $set(set.file) and stores it.
proc getinfo {} {
  global set
  if {![file isfile $set(data.dir)/$set(set.file)]} {
    putlog "> Could not locate the settings file?!"
    return
  }
  set rfile [open $set(data.dir)/$set(set.file) RDONLY]
  set set(cmd) [gets $rfile]
  set set(owner) [gets $rfile]
  set set(password) [gets $rfile]
  set set(adminpass) [gets $rfile]
  set set(channels) [gets $rfile]
  set set(homechan) [gets $rfile]
  set set(report) [gets $rfile]
  set set(backup) [gets $rfile]
  set set(maxhosts) [gets $rfile]
  set set(mail.name) [gets $rfile]
  set set(mail.addr) [gets $rfile]
  set set(mail.serv) [gets $rfile]
  set set(autoadd) [gets $rfile]
  set set(data.dir) [gets $rfile]
  set set(script.dir) [gets $rfile]
  set set(set.file) [gets $rfile]
  set set(quickban.file) [gets $rfile]
  set set(topics.file) [gets $rfile]
  set set(8ball.file) [gets $rfile]
  set set(nickserv) [gets $rfile]
  set set(nickusemsg) [gets $rfile]
  set set(nickghost) [gets $rfile]
  set set(chanserv) [gets $rfile]
  set set(noteserv) [gets $rfile]
  set set(servermode) [gets $rfile]
  set set(chanmode) [gets $rfile]
  set set(twomode) [gets $rfile]
  set set(usermode) [gets $rfile]
  set set(sockcommand) [gets $rfile]
  set set(listenport) [gets $rfile]
  set set(auth.file) [gets $rfile]
  set set(deauth.file) [gets $rfile]
  set set(adduser.file) [gets $rfile]
  set set(deluser.file) [gets $rfile]
  set set(banmask) [gets $rfile]
  close $rfile
}

### SETINFO: setinfo <variable> [<value>]
##  Stores the information from variable to file (opposite of 'getinfo')
proc setinfo {{var &NA&} {value &NA&}} {
  check_error "setinfo variable ?value?" $var &NA&
  global set
  if {[string tolower $var] != "all"} {
    set set([string tolower $var]) $value
  }
  if {[file isfile $set(data.dir)/$set(set.file)]} {
    file delete $set(data.dir)/$set(set.file)
  }
  set wfile [open $set(data.dir)/$set(set.file) "WRONLY CREAT"]
  puts $wfile $set(cmd)
  puts $wfile $set(owner)
  puts $wfile $set(nicpass)
  puts $wfile $set(adminpass)
  puts $wfile $set(channels)
  puts $wfile $set(homechan)
  puts $wfile $set(report)
  puts $wfile $set(backup)
  puts $wfile $set(maxhosts)
  puts $wfile $set(mail.name)
  puts $wfile $set(mail.addr)
  puts $wfile $set(mail.serv)
  puts $wfile $set(autoadd)
  puts $wfile $set(data.dir)
  puts $wfile $set(script.dir)
  puts $wfile $set(set.file)
  puts $wfile $set(quickban.file)
  puts $wfile $set(topics.file)
  puts $wfile $set(8ball.file)
  puts $wfile $set(nickserv)
  puts $wfile $set(nickusemsg)
  puts $wfile $set(nickghost)
  puts $wfile $set(chanserv)
  puts $wfile $set(noteserv)
  puts $wfile $set(servermode)
  puts $wfile $set(chanmode)
  puts $wfile $set(twomode)
  puts $wfile $set(usermode)
  puts $wfile $set(sockcommand)
  puts $wfile $set(listenport)
  puts $wfile $set(auth.file)
  puts $wfile $set(deauth.file)
  puts $wfile $set(adduser.file)
  puts $wfile $set(deluser.file)
  puts $wfile $set(banmask)
  close $wfile
}

### STARTUP_OPTIONS: startup_options
##  Creates all directories and settings needed to run Services
proc startup_options {} {
  global set
  putlog "> Gathering information from database files..."
  if {![file isfile $set(data.dir)/$set(set.file)]} {
    setinfo all
  } else {
    getinfo
  }
  putlog "> Checking directories..."
  if {![file isdirectory $set(script.dir)]} {
    putlog "> Could not find the services directory.. this is where your scripts are..."
    return error
  }    
  if {![file isdirectory $set(data.dir)]} {
    if {[catch {exec mkdir $set(data.dir)}]} {
      putlog "> Error: Could not create data directory."
      putlog "> Setup detected fatal error, Testikles`\[e\] need's this directory to run.."
      return error
    }
    putlog "> Created data directory successfully..."
  }
  putlog "> Checking files..."
  if {![file isfile $set(data.dir)/$set(quickban.file)]} {
    putlog "> Could not locate quickban file.. the 'ban -quick option' will not work without it."
  }
  if {![file isfile $set(data.dir)/$set(topics.file)]} {
    putlog "> Could not locate topics file.. the 'topic' command may not work properly."
  }
  if {![file isfile $set(data.dir)/$set(8ball.file)]} {
    putlog "> Could not locate 8ball file.. the 8ball will not work without it."
  }
  putlog "> Checking channels settings..."
  foreach channel $set(channels) {
    if {![file isfile $set(data.dir)/[file_change $channel].dat]} {
      putlog "> Creating settings file for $channel"
      addmainchan $channel
    }
    if {![file isfile $set(data.dir)/[file_change $channel].com]} {
      putlog "> Creating commands file for $channel"
      command_create $channel
    }
    if {![changet $channel active]} {
      continue
    } elseif {![validchan $channel]} {
      channel add $channel
      putlog "> Added channel $channel..."
      channel set $channel chanmode ""
    }
  }
  if {![validchan $set(homechan)]} {
    channel add $set(homechan)
    putlog "> Added home channel..."
  }
  if {![istimer check_settings]} {
    check_settings
  }
}

### NOTEOWNERSEND: noteownersend <channel> <note>
##  Sends the note to the channel owners
proc noteownersend {{chan &NA&} {note &NA&}} {
  check_error "noteownersend channel note-message" $note &NA&
  global set botnick
  foreach owner [changet $chan owner] {
    writefile $set(data.dir)/note.[file_change $owner] [unixtime]$owner[rand 9] "[unixtime] U {} $botnick {$note}"
    if {[notify $owner]} {
      notice $owner $owner "You just received a note from $botnick. /msg $botnick read [llength [notelist $owner]]"
    }
  }
}

### NOTELIST: notelist <nickname> [<type>]
##  Returns the notes for the nickname [new, old, all, del]
proc notelist {{nick &NA&} {type all}} {
  check_error "notelist nickname ?type?" $nick &NA&
  global set
  if {![file isfile $set(data.dir)/note.[file_change $nick]]} {
    return
  }
  set return ""
  set cnt 1
  foreach note [listfile $set(data.dir)/note.[file_change $nick]] {
    set readfile [readfile $set(data.dir)/note.[file_change $nick] $note]
    if {[string tolower $type] == "all"} {
      set return "$return \{$cnt $readfile $note\}"
    } elseif {[string tolower $type] == "old" && ([lindex $readfile 1] == "R" || [lindex $readfile 1] == "D")} {
      set return "$return \{$cnt $readfile $note\}"
    } elseif {[string tolower $type] == "new" && [lindex $readfile 1] == "U"} {
      set return "$return \{$cnt $readfile $note\}"
    } elseif {[string tolower $type] == "del" && [lindex $readfile 1] == "D"} {
      set return "$return \{$cnt $readfile $note\}"
    }
    incr cnt 1
  }
  return [string trim $return]
}

### FILE_CHANGE: file_change <channel>
##  Changes a channel name into a Windows-friendly filename (eg. #ChaNNeL/\:"*?><| into #channel---------)
proc file_change {{file &NA&}} {
  check_error "file_change text-for-filename" $file &NA&
  set return ""
  foreach chr [split $file ""] {
    if {$chr == "\/" || $chr == "\\" || $chr == "\:" || $chr == "\"" || $chr == "\*" || $chr == "\?" || $chr == "\>" || $chr == "\<" || $chr == "\|"} {
      set return $return-
    } else {
      set return $return$chr
    }
  }
  return [string tolower $return]
}

### COMMAND_CREATE: command_create <channel>
##  Creates the #chan.com file in the data directory for the access of commands
proc command_create {{chan &NA&}} {
  check_error "command_create channel" $chan &NA&
  global set
  if {![file isdir $set(script.dir)]} {
    return
  }
  if {[file isfile $set(data.dir)/[file_change $chan].com]} {
    file delete $set(data.dir)/[file_change $chan].com
  }
  set wfile [open $set(data.dir)/[file_change $chan].com "WRONLY CREAT"]
  puts $wfile "8ball==25"
  puts $wfile "access==1"
  puts $wfile "adduser==150"
  puts $wfile "ban==75"
  puts $wfile "clean==100"
  puts $wfile "commands==1"
  puts $wfile "comset==190"
  puts $wfile "delme==1"
  puts $wfile "deluser==150"
  puts $wfile "deop==100"
  puts $wfile "devoice==25"
  puts $wfile "fun==25"
  puts $wfile "info==1"
  puts $wfile "invite==25"
  puts $wfile "kick==50"
  puts $wfile "listban==1"
  puts $wfile "mdeop==190"
  puts $wfile "mdevoice==190"
  puts $wfile "mimic==25"
  puts $wfile "op==100"
  puts $wfile "resetdb==200"
  puts $wfile "seek==25"
  puts $wfile "set==190"
  puts $wfile "setuser==150"
  puts $wfile "topic==50"
  puts $wfile "unban==75"
  puts $wfile "voice==25"
  close $wfile
}

### CDURATION: cduration <time in seconds>
##  Changes seconds into format for idle/manager seen on info
proc cduration {{time &NA&}} {
  check_error "cduration seconds" $time &NA&
  set days [expr $time /60/24/60]
  set time [expr $time - ($days *60*24*60)]
  set hrs [expr $time /60/60]
  set time [expr $time - ($hrs *60*60)]
  set mins [expr $time /60]
  set time [expr $time - ($mins *60)]
  return "$days d, [align $hrs 2 0 R] h, [align $mins 2 0 R] m, [align $time 2 0 R] s"
}

### ALIGN: align <text> <length> <character> <type [L/R/C]>
##  Aligns text Left, Right or Centered [listban, access etc.]
proc align {{text &NA&} {num &NA&} {char " "} {type L}} {
  check_error "align text number ?character? ?type?" $num &NA&
  set a ""
  set b 1
  while {$b <= [expr $num - [string length $text]]} {
    set a $a$char
    incr b 1
  }
  if {[string toupper $type] == "R"} {
    return $a$text
  } elseif {[string toupper $type] == "L"} {
    return $text$a
  } elseif {[string toupper $type] == "C"} {
    return [letters $a [expr [string length $a] / 2]]$text[letters $a [expr [string length $a] / 2] 0]
  }
}

### CHAN_SETTINGS: chan_settings <command> <type> <nick> <uhost> <handle> <chan> <text>
##  Checks the idle, logs etc. and updates
proc chan_settings {{command &NA&} {type &NA&} {nick &NA&} {uhost &NA&} {handle &NA&} {chan &NA&} {text ""}} {
  check_error "chan_settings command type nickname userhost handle channel ?text?" $chan &NA&
  global set chaninfo
  set type [string tolower $type]
  set command [string tolower $command]
  set text [charstrip [string tolower $text]]
  if {![ischanopchan $chan]} {
    return
  }
  if {$type == "c" && $command != "info"} {
    chanset $chan idle [unixtime]
  }
  if {[level $handle $chan] >= "200" && $type != "-" && $command != "info"} {
    chanset $chan manseen [unixtime]
  }
  if {$type == "-"} {
    return
  }
  if {$type == "c"} {
    set type +
  } else {
    set type ""
  }
  write $set(data.dir)/[file_change $chan].logfile "\[[ctime [unixtime]] $set(timezone)\] ($handle) $nick!$uhost $type$command $chan $text"
}

### WRITE: write <filename> <text>
##  Writes 'text' to the 'filename' at the end of the line (this works in windows)
proc write {{file &NA&} {text &NA&}} {
  check_error "write filename text" $text &NA&
  set wfile [open $file a+]
  puts $wfile $text
  close $wfile
}

### NOTIFY_SEND: notify_send
##  Sends the message to the server to see if people are online
proc notify_send {} {
  global botnick
  putquick "ISON :$botnick [userlist]"
}

### NOTIFY: notify <nickname>
##  Returns if a nickname is online or not from notify list
proc notify {{nick &NA&}} {
  check_error "notify nickname" $nick &NA&
  global notify
  if {![info exists notify([string tolower $nick])]} {
    return 0
  } else {
    return $notify([string tolower $nick])
  }
}

### READR: readr <filename>
##  Just reads a random line of the filename
proc readr {{file &NA&}} {
  check_error "readr filename" $file &NA&
  if {![file isfile $file]} {
    return
  }
  set lines 0
  set rfile [open $file RDONLY]
  while {![eof $rfile]} {
    incr lines 1
    gets $rfile
  }
  close $rfile
  set line [rand $lines]
  set lines 0
  set rfile [open $file RDONLY]
  while {![eof $rfile]} {
    incr lines 1
    if {$lines == $line} {
      set line [gets $rfile]
      close $rfile
      return $line
    }
    gets $rfile
  }
  close $rfile
}

### WRITEFILE: writefile <filename> <topic> <value>
##  Write's to a file similar to ini files but not as in depth. Used only for addon scripts in non-Windows based
proc writefile {{file &NA&} {topic &NA&} {value &NA&}} {
  check_error "writefile filename heading value" $value &NA&
  set rfile [open $file "RDONLY CREAT"]
  set wfile [open $file~wr "WRONLY CREAT"]
  set no 0
  set line [gets $rfile]
  while {![eof $rfile]} {
    if {[string match [string tolower $topic]==* [string tolower $line]]} {
      set no 1
      puts $wfile $topic==$value
      set line [gets $rfile]
    } else {
      puts $wfile $line
      set line [gets $rfile]
    }
  }
  if {!$no} {
    puts $wfile $topic==$value
  }
  close $rfile
  close $wfile
  file delete $file
  file rename $file~wr $file
}

### READFILE: readfile <filename> <topic>
##  Read's from a file similar to ini files but not as in depth. Used only for addon scripts
proc readfile {{file &NA&} {topic &NA&}} {
  check_error "readfile filename heading" $topic &NA&
  if {![file isfile $file]} { return }
  set rfile [open $file RDONLY]
  set line [gets $rfile]
  while {![eof $rfile]} {
    if {[string match [string tolower $topic]==* [string tolower $line]]} {
      close $rfile
      return [letters $line [string length $topic==] 0]
    }
    set line [gets $rfile]
  }
  close $rfile
}

### REMFILE: remfile <filename> <topic>
##  Remove's a topic from a file similar to ini files but not as in depth. Used only for addon scripts in non-Windows based
proc remfile {{file &NA&} {topic &NA&}} {
  check_error "remfile filename heading" $topic &NA&
  if {![file isfile $file]} { return }
  set rfile [open $file RDONLY]
  set wfile [open $file~wr "WRONLY CREAT"]
  set line [gets $rfile]
  while {![eof $rfile]} {
    if {![string match [string tolower $topic]==* [string tolower $line]]} {
      puts $wfile $line
      set line [gets $rfile]
    } else {
      set line [gets $rfile]
    }
  }
  close $rfile
  close $wfile
  file delete $file
  file rename $file~wr $file
}

### LISTFILE: listfile <filename> [<number><topic>]
##  This is similar to the mIRC '$ini' but different, experement with how it works..
proc listfile {{file &NA&} {type ""}} {
  check_error "listfile filename ?N|topic?" $file &NA&
  if {![file isfile $file]} { return }
  if {$type == ""} {
    set rfile [open $file RDONLY]
    set return ""
    while {![eof $rfile]} {
      gets $rfile line
      set st ""
      set chr2 ""
      foreach chr [split $line ""] {
        if {"$chr$chr2" == "=="} {
          set return "$return$st "
        } else {
          set st $st$chr2
        }
        set chr2 $chr
      }
    }
    close $rfile
    return $return
  } elseif {[isnum $type]} {
    set rfile [open $file RDONLY]
    set cnt 1
    while {![eof $rfile]} {
      gets $rfile line
      if {$cnt == $type} {
        set st ""
        set chr2 ""
        foreach chr [split $line ""] {
          if {"$chr$chr2" == "=="} {
            close $rfile
            return $st
          } else {
            set st $st$chr2
          }
          set chr2 $chr
        }
      }
      incr cnt 1
    }
    close $rfile
  } else {
    set rfile [open $file RDONLY]
    set cnt 1
    while {![eof $rfile]} {
      gets $rfile line
      if {[string match [string tolower $type]==* [string tolower $line]]} {
        close $rfile
        return $cnt
      }
      incr cnt 1
    }
    close $rfile
  }
}

### REMOVE_LOGFILES: remove_logfiles
##  Goes through all the channels in the settings and removes logfiles from them
proc remove_logfiles {} {
  global set
  putlog "> Removing all channel logfiles..."
  foreach chan $set(channels) {
    if {[file isfile $set(data.dir)/[file_change $chan].logfile]} {
      file delete $set(data.dir)/[file_change $chan].logfile
    }
  }
}

### CHECKUSERS: checkusers
##  Checks the &banlist& and &suspend users for all the required information.
proc checkusers {} {
  if {![validuser &banlist&]} {
    putlog "> Could not find banlist user... adding..."
    adduser &banlist&
    setuser &banlist& pass &BANLIST&
    chattr &banlist& +U
  }
  if {![validuser &suspend&]} {
    putlog "> Could not find suspends user... adding..."
    adduser &suspend&
    setuser &suspend& pass &SUSPENSIONS&
    chattr &suspend& +U
  }
}
### GETBANREASON: getbanreason <channel> <banmask>
##  Returns the ban reason for the banmask on the channel
proc getbanreason {{chan &NA&} {ban &NA&}} {
  check_error "getbanreason channel banmask" $ban &NA&
  checkusers
  if {[getuser &banlist& XTRA $chan,$ban] == ""} {
    return "You are banned"
  } else {
    return [getuser &banlist& XTRA $chan,$ban]
  }
}

### SCRIPT_ERROR: script_error <procedure> <error message>
##  Reports errors to home channel and partyline
proc script_error {{proc &NA&} {error &NA&}} {
  check_error "script_error procname error-message" $error &NA&
  if {$error != "need op"} {
    putlog "> error ;$proc; '$error'"
    homechan ">> error ;$proc; '$error'"
    write debug.log "\[[ctime [unixtime]]\] ($proc): $error"
  }
}

### *_ERROR: *_error <procedure> [<other shit that goes with..>]
##  Below this is for every command used in this script to search for bugs

proc msg_error {proc nick uhost handle text} {
  if {[catch {$proc $nick $uhost $handle $text} error]} {
    script_error $proc $error
  }
}

proc dcc_error {proc handle idx text} {
  if {[catch {$proc $handle $idx $text} error]} {
    script_error $proc $error
  }
}

proc msgm_error {proc nick uhost handle text} {
  if {[catch {$proc $nick $uhost $handle $text} error]} {
    script_error $proc $error
  }
}

proc pubm_error {proc nick uhost handle chan text} {
  if {[catch {$proc $nick $uhost $handle $chan $text} error]} {
    script_error $proc $error
  }
}

proc notc_error {proc nick uhost handle text {dest ""}} {
  if {[catch {$proc $nick $uhost $handle $text $dest} error]} {
    script_error $proc $error
  }
}

proc join_error {proc nick uhost handle chan} {
  if {[catch {$proc $nick $uhost $handle $chan} error]} {
    script_error $proc $error
  }
}

proc part_error {proc nick uhost handle chan {text ""}} {
  if {[catch {$proc $nick $uhost $handle $chan $text} error]} {
    script_error $proc $error
  }
}

proc sign_error {proc nick uhost handle chan reason} {
  if {[catch {$proc $nick $uhost $handle $chan $reason} error]} {
    script_error $proc $error
  }
}

proc topc_error {proc nick uhost handle chan topic} {
  if {[catch {$proc $nick $uhost $handle $chan $topic} error]} {
    script_error $proc $error
  }
}

proc kick_error {proc nick uhost handle chan victim reason} {
  if {[catch {$proc $nick $uhost $handle $chan $victim $reason} error]} {
    script_error $proc $error
  }
}

proc nick_error {proc nick uhost handle chan newnick} {
  if {[catch {$proc $nick $uhost $handle $chan $newnick} error]} {
    script_error $proc $error
  }
}

proc mode_error {proc nick uhost handle chan mode victim} {
  if {[catch {$proc $nick $uhost $handle $chan $mode $victim} error]} {
    script_error $proc $error
  }
}

proc pub_error {proc nick uhost handle chan text} {
  if {[catch {$proc $nick $uhost $handle $chan $text} error]} {
    script_error $proc $error
  }
}

proc raw_error {proc server num text} {
  if {[catch {$proc $server $num $text} error]} {
    script_error $proc $error
  }
}

proc evnt_error {proc type} {
  if {[catch {$proc $type} error]} {
    script_error $proc $error
  }
}
